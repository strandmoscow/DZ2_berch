\subsection{Цель выполнения лабораторной работы}\label{blockN.VariantM}
\textbf{Цель выполнения лабораторной работы }-- \GoalOfResearch

%-------------------------------------------------
\subsection{Задание}
Для цепи Маркова, заданной стохастической матрицей переходов:
\begin{enumerate}
    \item нарисовать граф цепи;
    \item выделить классы существенных и несущественных состояний (вручную – обязательно; программным путём – дополнительное задание для желающих);
    \item рассчитать предельные вероятности для классов существенных состояний;
    \item не выполняя матричных операций с полной стохастической матрицей переходов, записать предельные вероятности в следующих случаях:
    \begin{enumerate}
        \item[4.1] если достоверно известно, что система начинает работу в каком-то одном из состояний (для каждого исходного состояния – свой предельный вектор);
        \item[4.2] если известно, что начальное распределение вероятностей – равновероятное среди всех несущественных состояний;
    \end{enumerate}
    \item провести имитационное моделирование системы, соответствующей рассматриваемой цепи, для этого:
    \begin{itemize}
        \item перебираем все состояния в качестве исходных;
        \item случайно разыграть переход в новое состояние, учитывая распределение вероятностей перехода;
        \item совершить 100 переходов;
        \item подсчитать число вхождений в каждое из состояний системы;
        \item повторить эксперимент 10 раз для каждого исходного состояния;
        \item  построить <<графики>> переключений состояний цепи (для наглядности соединяем дискретные точки);
    \end{itemize}
\end{enumerate}
%-------------------------------------------------
\newpage
\subsection{Решение}
Дана стохастическая матрица переходов $\mathbf{P}$:

$$\mathbf{P}=\begin{pmatrix}
0.12 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.36 & 0.0 & 0.0 & 0.0 & 0.0 & 0.52 & 0.0 \\
0.0 & 0.12 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.24 & 0.0 & 0.12 & 0.52 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.24 & 0.24 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.52 & 0.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.12 & 0.0 & 0.0 & 0.36 & 0.0 & 0.0 & 0.0 & 0.0 & 0.52 & 0.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.23 & 0.0 & 0.21 & 0.15 & 0.0 & 0.0 & 0.23 & 0.0 & 0.0 & 0.0 & 0.18 \\
0.0 & 0.0 & 0.24 & 0.0 & 0.0 & 0.24 & 0.0 & 0.0 & 0.0 & 0.0 & 0.52 & 0.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.18 & 0.0 & 0.21 & 0.3 & 0.1 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.21 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.29 & 0.0 & 0.23 & 0.26 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.22 \\
0.24 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.24 & 0.0 & 0.0 & 0.0 & 0.0 & 0.52 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.12 & 0.88 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.29 & 0.13 & 0.0 & 0.27 & 0.0 & 0.0 & 0.0 & 0.0 & 0.31 & 0.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.24 & 0.76 & 0.0 & 0.0 \\
0.0 & 0.22 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.28 & 0.0 & 0.25 & 0.25 & 0.0 & 0.0 \\
0.3 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.33 & 0.0 & 0.0 & 0.0 & 0.0 & 0.37 & 0.0 \\
0.0 & 0.21 & 0.0 & 0.0 & 0.25 & 0.0 & 0.2 & 0.15 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.19 
\end{pmatrix}$$

На рисунке \ref{graph} представлен граф переходов, соответствующий матрице $\mathbf{P}$ (состояния из серого кластера в совокупности дают класс несущественных состояний).
\begin{figure}[H]
\centerline{\includegraphics[scale = .85]{Images/graph.jpg}}
\caption{Граф переходов}
\label{graph}
\end{figure}

\subsubsection{Определение вектора предельных вероятностей для классов существенных состояний}

Рассмотрим каждый класс существенных состояний как отдельный марковский процесс.

Была разработана функция, генерирующая матрицу для кластера, заданного списком состояний.

\begin{lstlisting}[language=python, label=prog,caption={\textit{Генерация стахастической матрицы переходов внутри кластера}}]
def make_class_matrix(class_states, P):
    n = len(class_states)
    class_matrix = np.zeros((n, n))
    k = 0

    for i in np.sort(class_states):
        row_prob = []
        for indx in range(len(P[i - 1])):
            if indx+1 in class_states:
                row_prob.append(P[i - 1][indx])
        class_matrix[k] = row_prob
        k += 1

    return class_matrix
\end{lstlisting}

Таким образом имеем 3 матрицы ($\mathbf{P_{1}}, \quad \mathbf{P_{2}}, \quad \mathbf{P_{3}}$) определяющие переходы внутри классов.

$$\mathbf{P_{1}}=
\begin{pmatrix}
    0.12 & 0.36 & 0.52 \\
0.24 & 0.24 & 0.52 \\
0.3 & 0.33 & 0.37 
\end{pmatrix}$$

$$\mathbf{P_{2}}=
\begin{pmatrix}
    0.12 & 0.24 & 0.12 & 0.52 \\
0.0 & 0.0 & 0.12 & 0.88 \\
0.0 & 0.0 & 0.24 & 0.76 \\
0.22 & 0.28 & 0.25 & 0.25 
\end{pmatrix}$$

$$\mathbf{P_{3}}=
\begin{pmatrix}
    0.24 & 0.24 & 0.0 & 0.52 \\
0.12 & 0.0 & 0.36 & 0.52 \\
0.24 & 0.0 & 0.24 & 0.52 \\
0.29 & 0.13 & 0.27 & 0.31 
\end{pmatrix}$$

~\\

Далее по известной формуле находим вектор предельных вероятностей.

$$(\mathbf{P}^T-\mathbf{E})\times\overline{p}=\overline{0},$$
где $\overline{p}$--вектор предельных вероятностей

Однако, поскольку система является линейно зависимой в качестве последнего уравнения внесем условие $\sum\limits_{i=1}^{n_{vertex}}p_i=1$.

~\\

Была реализована функция, вычисляющая вектор предельных вероятностей  $\overline{p}$.

\begin{lstlisting}[language=python, label=prog,caption={\textit{расчет вектора предельных вероятностей}}]
def marginal_probabilities(P, sum_p=1):
    A = P.T - np.eye(len(P), dtype=float)
    A[-1] = np.full(len(P), 1)
    b = np.zeros(len(P))
    b[-1] = sum_p
    p = np.linalg.solve(A, b)

    return p
\end{lstlisting}

Таким образом, векторы предельных вероятностей:
$$\overline{p}_{red}=(0.2385\quad0.3093\quad0.4522 \\
)^T$$

$$\overline{p}_{green}=( 0.1242\quad0.169\quad0.2098\quad0.497 \\
 )^T$$

$$\overline{p}_{orange}=( 0.2477\quad0.1153\quad0.2073\quad0.4298 \\
 )^T$$

\newpage
\subsubsection{Модификация стохастической матрицы}
Для дальнейших вычислений, а также наглядной визуализации результатов моделирования необходимо отсортировать матрицу.

Была реализована функция изменения матрицы по списку состояний.
 \begin{lstlisting}[language=python, label=prog, caption={\textit{Модификация матрицы}}]
def change_matrix(pos, P):
    n = len(P)
    sort_matrix = np.zeros((n, n))
    for i in range(len(P)):
        sort_matrix[i]=P[pos[i]-1]

    sort_matrix = sort_matrix.T
    for i in range(len(sort_matrix)):
        P[i] = sort_matrix[i]
    for i in range(len(P)):
        sort_matrix[i]=P[pos[i]-1]
    return sort_matrix.T
\end{lstlisting}

Граф соответствующий измененной стохастической матрице (для удобства кластеры выделены тем же цветом).

\begin{figure}[H]
\centerline{\includegraphics[scale = .85]{Images/new_grapg.jpg}}
\caption{Модифицированный граф}
\label{graph}
\end{figure}


\newpage
\subsubsection{Определение вектора предельных вероятностей для всех состояний}
Для эффективности вычислений выполним свертку кластеров существенных состояний, представив каждый кластер существенных состояний,
как одно состояние с единичным переходом в самого себя (рисунок \ref{sver_gr}).

\begin{figure}[H]
%\centerline{\includegraphics[scale = 0.8]{Images/iter.png}}
\caption{Граф после свертки}
\label{sver_gr}
\end{figure}

Данному графу соответсвует следующая стохастическая матрица переходов:

% Свернутая матрица
$$
\mathbf{P}(n)=
\begin{pmatrix}
0.23 & 0.21 & 0.15 & 0.18 & 0.0 & 0.0 & 0.23 \\
0.18 & 0.21 & 0.3 & 0.21 & 0.1 & 0.0 & 0.0 \\
0.29 & 0.23 & 0.26 & 0.22 & 0.0 & 0.0 & 0.0 \\
0.25 & 0.2 & 0.15 & 0.19 & 0.0 & 0.21 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 
\end{pmatrix}
$$

На основе полученной стохастической матрицы получим предельную матрицу, которая может быть вычеслена следующим образом:

$$
    \mathbf{P} (n) = \mathbf{P}^n
$$

В пределе вероятность оказаться в любом состоянии, пренадлежащем несущественному кластеру, равна 0.
Таким образом можно сформулировать критерий остановки последовательности $\mathbf{P} (n) = \mathbf{P} \cdot \mathbf{P} \cdot \mathbf{P} \cdot \dots$.
Будем считать, что матрица сошлась к предельной, когда сумма вероятностей переходов внутри несущественного кластера будет меньше заданного $\epsilon$.

\begin{lstlisting}[language=python, label=prog,caption={\textit{Нахождение предельной матрицы переходов}}]
    def P_n(P_svert, n):
        eps = 0.0001
        s = 1
        while s > eps:
            P_svert = P_svert.dot(P_svert)
            s = 0
            for j in range(n):
                s += np.sum(P_svert[j][0:n])
        return P_svert
\end{lstlisting}

В результате выполнения функции получена следующая матрица:

$$
\mathbf{P}(n)=
\begin{pmatrix}

\end{pmatrix}
$$

Далее рассматриваем возможные старты только из состояний, принадлежащих несущественному кластеру
(при старте из любого состояния существенного кластера вектор предельных вероятностей будет состоять из нулей и значений
при рассчете вероятностей для каждого конкретного кластера).
Пусть имеется один кластер несущественных состояний и три кластера существенных состояний, тогда
$$
    \mathbf{P} (n)^T \cdot \pi = (0, \, 0, \, 0 \,...\,x,\, y,\, z)^T,
$$
где $\pi$ - вектор, состоящий из всех нулей за исключением состояния, из которого осуществляется старт (там стоит 1),
$x, y, z$ - предельные вероятности оказаться в одном из существенных кластеров.
Количество лидирующих нулей равно количеству состояний в несущественном кластере.

Таким образом искомые вектора могут быть найдены в виде 
$p = (0,\, 0,\, 0\,...\,x \cdot p_1, y\cdot p_2, z\cdot p_3)^T$.

\begin{table}
    \begin{tabular}[c]
	p_1 = 0, 0, 0, 0, 0.0334, 0.0433, 0.0633, 0.0338, 0.046, 0.0571, 0.1354, 0.1455, 0.0678, 0.1218, 0.2525 \\
 	p_2 = 0, 0, 0, 0, 0.063, 0.0817, 0.1194, 0.0406, 0.0552, 0.0685, 0.1623, 0.1014, 0.0472, 0.0849, 0.1759 \\
 	p_3 = 0, 0, 0, 0, 0.0427, 0.0554, 0.081, 0.0439, 0.0598, 0.0742, 0.1758, 0.1157, 0.0539, 0.0969, 0.2008 \\
 	p_4 = 0, 0, 0, 0, 0.0338, 0.0438, 0.064, 0.0608, 0.0827, 0.1027, 0.2432, 0.0914, 0.0425, 0.0765, 0.1586
    \end{tabular}
\end{table}

~\\

Найдем вектор предельныех вероятностей если известно, что начальное распределение вероятностей – равновероятное среди
всех несущественных состояний.
Для рассматриваемого случая вектор $\pi$ будет иметь вид $[1/n, 1/n...0, 0,...0]$,
где количество ненулевых элементов равно n - количеству состояний в несущественном кластере, а количество нулевых
позиций соотвествует количеству существенных кластеров.

%ans2
\textbf{ВСТАВИТЬ ОТВЕТ}


\newpage
\subsubsection{Имитационное моделирование}

Была разработана функция, реализующая переходы, заданное число раз, возвращающая траекторию и список с количеством посещений для каждого состояния (индексы -- состояния).

 \begin{lstlisting}[language=python, label=prog,caption={\textit{реализация марковского процесса}}]
def mark_iter(n, m, states, s_start):
    current_s = s_start
    states_tr = [current_s]
    n_entry = [0 for _ in range(len(states))]
    for _ in range(n - 1):
        per_ver = m[current_s - 1]
        n_entry[current_s - 1] += 1
        next_s = np.random.choice(states, p=per_ver)
        current_s = next_s
        states_tr.append(current_s)
    return n_entry, states_tr
\end{lstlisting}

На рисунке \ref{iter} представлены «графики» переключений состояний цепи.

\begin{figure}[H]
\centerline{\includegraphics[scale = 0.8]{Images/iter.png}}
\caption{Переключения состояния цепи}
\label{iter}
\end{figure}

%-------------------------------------------------
\subsection{Вывод}
В ходе выполнения домашнего задания №1 была проанализирована работа марковского процесса, заданного стохастической матрицей переходов.

% --------------------------------------
% Атрибуты задачи
\labattributes{}{}{}{}{студент группы \EduGroup, \Author}{\Year, \Semestr}
%--------------
